  program FEMGeo_Wr
!-----------------------------------------------------------------------------------!
!   Program pip1:
!   Point in Polyhedron
!   Version 0.80125 (2008   January 25) (Subversion:9)
!   Roman Schuh
!   1 Command line parameter: Maximum shape size in dipoles
!
!
!
!                                                                                   !
!  The program calls the ivread_wr.f90 subroutine.                                  !
!  This routine is based on the ivread.f90 routine by John Burkardt (1999).         !
!  The program converts various computer graphics files formates                    !
!  (dxf, obj, oogl, smf, vmrl) into the .FEM format needed with TNONAXSYM.          !
!  (Have a look at the comments in ivread).                                         !
!                                                                                   !
!  But the focus of the program FEMGeo_Wr is on the wavefront .obj file format.     ! 
!  The input .obj file should such be such that it only consists of triangular (!!) !
!  surface patches! No free form curves are supported.                              !
!  All dimensions are in microns.                                                   !
!                                                                                   !
!  This .obj file format will also be generated by the SScaTT (superellipsoid       !
!  scattering tool), which is also included on this CD.                             !
!  FEMGeo has not been tested with the other file formats that can be read by the   !
!  ivread.f90 routine.                                                              !
!                                                                                   !
!  The Hyperfun program (www.hyperfun.org) is suitable for generation of other      !
!  particle shapes. For conversion to .obj, visualization and scaling you may use   !
!  Deep Exploration (www.righthemisphere.com), for grid reduction you may use       !
!  Rational Reducer Professional (www.rational-reducer.com).                        ! 
!  To increase the number of faces of a body you can use a divide by four           !
!  subdivision scheme implemented in the Triangles                                  !
!  DOS program (www.geocities.com/Athens/Academy/8764/triangdoc.html).              !
!  A divide by three or by four scheme is also included in MilkShape-1.5.7.         !                                                            !
!                                                                                   !
!-----------------------------------------------------------------------------------!
  integer, parameter :: face_max = 100000
  integer, parameter :: node_max = 100000
  integer, parameter :: face_order_max = 3
  
  integer node_num
  integer na
  integer face_num, n_surfaces
  real face_point(3,face_max)
  real face_normal(3,face_max)
  real face_area(face_max)
  character (len = 100) filein_name,name_out
  integer face_order(face_max)
  integer face(face_order_max,face_max)
  real v4(3,node_max)
  real (kind = 8) vv(3,node_max)
  real (kind = 8) pp(3)
  logical inside
  
  integer, parameter :: MXNAT = 2500000
  INTEGER NAT
  INTEGER*2 ICOMP(MXNAT,3),IXYZ(MXNAT,3)
  REAL A1(3),A2(3),DX(3)
  INTEGER JX,JY,JZ,NB,NFAC,NLAY,NX2,NY1,NY2,NZ1,NZ2
  REAL ASPR,PI,REFF2,Y2M,YCM,Z2,ZCM

  real xave,xrange
  real xmax
  real xmin
  real yave,yrange
  real ymax
  real ymin
  real zave,zrange
  real zmax
  real zmin
  real maxxyz,xyzscale
  real array (3)
  integer maxpos,numiargc
  integer NBX,NBY,NBZ
  integer xsh,ysh,zsh, shape_size
  character*80 strafg
  
!
!   only particles consisting of one (!) closed surface are considered 
!
	n_surfaces=1

    numiargc=iargc()

    ! read parameters
    if(numiargc.eq.0) then
        shape_size = 80
    else if (numiargc.eq.1) then
        call getarg(1,strafg)
        read(unit=strafg,fmt=*) shape_size
        filein_name='shape.obj'
    else
        call getarg(1,strafg)
        read(unit=strafg,fmt=*) shape_size 
        call getarg(2, filein_name)
    end if


    print *, 'Maximum shape size = ', shape_size

    xsh = shape_size
    ysh = shape_size
    zsh = shape_size
    
    NAT = 0

    DX(1) = 1.0
    DX(2) = 1.0
    DX(3) = 1.0
    
    face_order = 3
!
!   .obj input file name
!
!
	call ivread_wr(filein_name,face_point,face_normal,face_area,face_num,node_num,v4,face)
    

	vv(1:3,1:node_num)=dble(v4(1:3,1:node_num))
	
    call cor3_limits(node_max, node_num, v4, xmin, xave, xmax, ymin, yave, ymax, zmin, zave, zmax)
    
      PI=4.*ATAN(1.)

      DO JX=1,3
         A1(JX)=0.
         A2(JX)=0.
      ENDDO
      
      A1(1)=1.
      A2(2)=1.

      xrange=xmax-xmin
      yrange=ymax-ymin
      zrange=zmax-zmin
      
      maxxyz=max(xrange,yrange,zrange)
      array(1)=xrange
      array(2)=yrange
      array(3)=zrange
      maxpos=maxloc(array,1)

      IF(maxpos == 1)THEN
         NBX=xsh
         NBY=int(yrange/xrange*xsh)
         NBZ=int(zrange/xrange*xsh)
         xyzscale=xsh/xrange
      ENDIF
      IF(maxpos == 2)THEN
         NBX=int(xrange/yrange*ysh)
         NBY=ysh
         NBZ=int(zrange/yrange*ysh)
         xyzscale=ysh/yrange
      ENDIF
      IF(maxpos == 3)THEN
         NBX=int(xrange/zrange*zsh)
         NBY=int(yrange/zrange*zsh)
         NBZ=zsh
         xyzscale=zsh/zrange
      ENDIF


      IF(2*(NBX/2).LT.NBX)THEN
         XCM=0.
         NX1=-NBX/2
         NX2=NBX/2
      ELSE
         XCM=0.5
         NX1=-NBX/2+1
         NX2=NBX/2
      ENDIF
      IF(2*(NBY/2).LT.NBY)THEN
         YCM=0.
         NY1=-NBY/2
         NY2=NBY/2
      ELSE
         YCM=0.5
         NY1=-NBY/2+1
         NY2=NBY/2
      ENDIF
      IF(2*(NBZ/2).LT.NBZ)THEN
         ZCM=0.
         NZ1=-NBZ/2
         NZ2=NBZ/2
      ELSE
         ZCM=0.5
         NZ1=-NBZ/2+1
         NZ2=NBZ/2
      ENDIF



      DO JZ=NZ1,NZ2
         DO JY=NY1,NY2
            DO JX=NX1,NX2
               pp(1)=1.1*dble(JX)/dble(xyzscale)+dble(xmax+xmin)/2.
               pp(2)=1.1*dble(JY)/dble(xyzscale)+dble(ymax+ymin)/2.
               pp(3)=1.1*dble(JZ)/dble(xyzscale)+dble(zmax+zmin)/2.
               call polyhedron_contains_point_3d ( node_num, face_num, &
               face_order_max, vv, face_order, face, pp, inside )
               IF (inside .eqv. .true.) THEN
                  NAT=NAT+1
                  IXYZ(NAT,1)=JX
                  IXYZ(NAT,2)=JY
                  IXYZ(NAT,3)=JZ
                  ICOMP(NAT,1)=1
                  ICOMP(NAT,2)=1
                  ICOMP(NAT,3)=1
               ENDIF
            ENDDO
         ENDDO
         WRITE(*,*)JZ,NAT
      ENDDO

    WRITE(*,*) NAT
    OPEN(UNIT=12,FILE='shape.dat',STATUS='UNKNOWN')
    
    WRITE(12,FMT=92)NBX,NBY,NBZ,NAT,A1,A2,DX
    
    DO JX=1,NAT
       WRITE(12,FMT=93)JX,IXYZ(JX,1),IXYZ(JX,2),IXYZ(JX,3),ICOMP(JX,1),ICOMP(JX,2),ICOMP(JX,3)
    ENDDO

    CLOSE(UNIT=12)



92 Format(' >PIPOBJ: point-in-polyhedron: NBX, NBY, NBZ=',3I4,/,&
       I7,' = NAT',/,&
       3F9.4,' = A_1 vector',/,&
       3F9.4,' = A_2 vector',/,&
       3F9.6,' = lattice spacings (d_x,d_y,d_z)/d',/,&
       ' 0.0 0.0 0.0',/,&
       '     JA  IX  IY  IZ ICOMP(x,y,z)')
93 Format(I7,3I5,3I2)

end

